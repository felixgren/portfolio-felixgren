/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three';
import React, { useEffect, useRef, useState } from 'react';
import { useGLTF, useAnimations, PerspectiveCamera } from '@react-three/drei';
import { useFrame } from '@react-three/fiber';

const color = new THREE.Color();

export default function Model({ scroll, ...props }) {
  const t = useRef(0);
  const group = useRef();
  const cameraRef = useRef();
  const groupCameraRef = useRef();
  const defaultPos = new THREE.Vector3(0, 0, 0);
  const defaultQuart = new THREE.Quaternion(0, 0, 0, 1);
  const localCamPosVec = new THREE.Vector3();
  const animStartPosition = new THREE.Vector3(-10.722, -5.981, 2.297);
  const animStartQuaternion = new THREE.Quaternion(
    0.17168,
    -0.77445,
    0.23707,
    0.56084
  );
  const worldCameraPosition = new THREE.Vector3();
  const worldCameraDirection = new THREE.Vector3();
  const worldCameraQuaternion = new THREE.Quaternion();
  const { nodes, materials, animations } = useGLTF('/model.glb');
  const { actions, clips, mixer } = useAnimations(animations, group);
  const [cameraReady, setCameraReady] = useState(false);
  const [toggle, setToggle] = useState(true);
  const [hovered, set] = useState();
  const extras = {
    receiveShadow: true,
    castShadow: true,
    'material-envMapIntensity': 0.2,
  };
  const scrollStart = 0;
  const transitionPhase = 0.4;
  const secondPhase = 0.5;
  const scrollEnd = 1;
  // const [isAnimating, setIsAnimating] = useState(false);

  useEffect(() => void actions['CameraAction.005'].play(), []);

  useEffect(() => {
    if (hovered)
      group.current.getObjectByName(hovered).material.color.set('white');
    document.body.style.cursor = hovered ? 'pointer' : 'auto';
  }, [hovered]);

  useFrame((state) => {
    state.camera.getWorldPosition(worldCameraPosition);
    state.camera.getWorldDirection(worldCameraDirection);
    state.camera.getWorldQuaternion(worldCameraQuaternion);
    // console.log(worldCameraPosition);
    // console.log(worldCameraDirection);
    // console.log(worldCameraQuaternion);

    const step = 0.05;
    state.camera.fov = THREE.MathUtils.lerp(
      state.camera.fov,
      toggle ? 90 : 28,
      step
    );
    state.camera.position.lerp(
      localCamPosVec.set(toggle ? 0 : 0, toggle ? 0 : 0, toggle ? 0 : 0),
      step
    );
    state.camera.updateProjectionMatrix();

    if (
      scroll.current < transitionPhase &&
      !actions['CameraAction.005'].isRunning()
    ) {
      groupCameraRef.current.position.lerp(defaultPos, 0.02);
      state.camera.quaternion.slerp(defaultQuart, 0.05);
    }

    if (
      !actions['CameraAction.005'].isRunning() &&
      scroll.current > transitionPhase &&
      scroll.current < secondPhase
    ) {
      setCameraReady(false);
      groupCameraRef.current.position.lerp(animStartPosition, 0.02);
      state.camera.quaternion.slerp(animStartQuaternion, 0.05);
    }

    if (scroll.current > secondPhase && cameraReady) {
      cameraRef.current.rotation.set(-Math.PI / 2, 0, 0);
      actions['CameraAction.005'].play();
      mixer.setTime(
        (t.current = THREE.MathUtils.lerp(
          t.current,
          // Calculate scroll between 0.5 and 1.0
          THREE.MathUtils.mapLinear(
            scroll.current,
            secondPhase,
            scrollEnd,
            scrollStart,
            actions['CameraAction.005']._clip.duration
          ),
          0.05
        ))
      );
    } else if (scroll.current > secondPhase && !cameraReady) {
      groupCameraRef.current.position.lerp(animStartPosition, 0.05);
      state.camera.quaternion.slerp(animStartQuaternion, 0.1);
      if (
        !cameraReady &&
        Math.abs(
          groupCameraRef.current.position.distanceTo(animStartPosition)
        ) < 0.1
      ) {
        setCameraReady(true);
        console.log('Camera is ready to switch!');
      }
    } else {
      mixer.setTime(
        (t.current = THREE.MathUtils.lerp(t.current, scrollStart, 0.05))
      );

      if (t.current < 0.02 && actions['CameraAction.005'].isRunning()) {
        actions['CameraAction.005'].stop();
        groupCameraRef.current.position.copy(animStartPosition);
        cameraRef.current.rotation.setFromQuaternion(animStartQuaternion);
      }
    }

    group.current.children[0].children.forEach((child, index) => {
      child.material.color.lerp(
        color
          .set(hovered === child.name ? 'blue' : '#202020')
          .convertSRGBToLinear(),
        hovered ? 0.1 : 0.05
      );
      const et = state.clock.elapsedTime;
      child.position.y = Math.sin((et + index * 2000) / 2) * 1;
      child.rotation.x = Math.sin((et + index * 2000) / 3) / 10;
      child.rotation.y = Math.cos((et + index * 2000) / 2) / 10;
      child.rotation.z = Math.sin((et + index * 2000) / 3) / 10;
    });
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group
        onPointerOver={(e) => (e.stopPropagation(), set(e.object.name))}
        onPointerOut={(e) => (e.stopPropagation(), set(null))}
        onClick={(e) => {
          setToggle(!toggle);
          console.log(`click model! ${e.object.name}`);
        }}
        position={[0.06, 4.04, 0.35]}
        scale={[0.25, 0.25, 0.25]}
      >
        <mesh
          name="Headphones"
          geometry={nodes.Headphones.geometry}
          material={materials.M_Headphone}
          {...extras}
        />
        <mesh
          name="Notebook"
          geometry={nodes.Notebook.geometry}
          material={materials.M_Notebook}
          {...extras}
        />
        <mesh
          name="Rocket003"
          geometry={nodes.Rocket003.geometry}
          material={materials.M_Rocket}
          {...extras}
        />
        <mesh
          name="Roundcube001"
          geometry={nodes.Roundcube001.geometry}
          material={materials.M_Roundcube}
          {...extras}
        />
        <mesh
          name="Table"
          geometry={nodes.Table.geometry}
          material={materials.M_Table}
          {...extras}
        />
        <mesh
          name="VR_Headset"
          geometry={nodes.VR_Headset.geometry}
          material={materials.M_Headset}
          {...extras}
        />
        <mesh
          name="Zeppelin"
          geometry={nodes.Zeppelin.geometry}
          material={materials.M_Zeppelin}
          v
        />
      </group>
      <group name="Camera" ref={groupCameraRef}>
        <PerspectiveCamera
          makeDefault
          ref={cameraRef}
          far={1000}
          near={0.1}
          fov={90}
        >
          <directionalLight
            castShadow
            position={[10, 20, 15]}
            shadow-camera-right={8}
            shadow-camera-top={8}
            shadow-camera-left={-8}
            shadow-camera-bottom={-8}
            shadow-mapSize-width={1024}
            shadow-mapSize-height={1024}
            intensity={2}
            shadow-bias={-0.0001}
          />
        </PerspectiveCamera>
      </group>
    </group>
  );
}

useGLTF.preload('/model.glb');
